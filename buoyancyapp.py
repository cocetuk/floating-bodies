# -*- coding: utf-8 -*-
"""BuoyancyApp.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12yZx22v8XyB9ZgJAZPRVwUUwupY2ZEOl
"""

import tkinter as tk
from tkinter import filedialog, messagebox, ttk
import tkinter.font as tkfont
import cv2
import numpy as np
import math
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import matplotlib.pyplot as plt
from matplotlib.patches import Polygon

# --- Вычислительные функции ---
def calculate_area(polygon):
    n = len(polygon)
    area = 0
    for i in range(n):
        x1, y1 = polygon[i]
        x2, y2 = polygon[(i + 1) % n]
        area += x1 * y2 - x2 * y1
    return abs(area) / 2


def find_units(polygon, distance_cm):
    xs = [p[0] for p in polygon]
    ys = [p[1] for p in polygon]
    px_length = max(max(xs) - min(xs), max(ys) - min(ys))
    return px_length / distance_cm


def find_intersection(p1, p2, h):
    x1, y1 = p1; x2, y2 = p2
    if (y1 - h) * (y2 - h) <= 0 and y1 != y2:
        x = x1 + (h - y1) * (x2 - x1) / (y2 - y1)
        return (x, h)
    return None


def submerged_polygon(vertices, h):
    sub = []
    for i in range(len(vertices)):
        p1, p2 = vertices[i], vertices[(i + 1) % len(vertices)]
        if p1[1] <= h:
            sub.append(p1)
        inter = find_intersection(p1, p2, h)
        if inter:
            sub.append(inter)
    return sub


def find_water_level(vertices, target_area, eps=1e-3):
    ymin = min(y for _, y in vertices)
    ymax = max(y for _, y in vertices)
    while ymax - ymin > eps:
        h = (ymin + ymax) / 2
        if calculate_area(submerged_polygon(vertices, h)) < target_area:
            ymin = h
        else:
            ymax = h
    return (ymin + ymax) / 2


def calculate_centroid(polygon):
    A = calculate_area(polygon)
    cx = cy = 0
    for i in range(len(polygon)):
        x0, y0 = polygon[i]
        x1, y1 = polygon[(i + 1) % len(polygon)]
        cross = x0 * y1 - x1 * y0
        cx += (x0 + x1) * cross
        cy += (y0 + y1) * cross
    factor = 1 / (6 * A) if A != 0 else 0
    return cx * factor, cy * factor


def potential_energy(polygon, units, m, g, density, thickness):
    S_phys = m / (density * thickness)
    h = find_water_level(polygon, S_phys * units**2)
    submerged = submerged_polygon(polygon, h)
    Gx, Gy = calculate_centroid(polygon)
    Bx, By = calculate_centroid(submerged)
    return m * g * ((Gy - By) / units)


def find_equilibrium_angle(polygon, units, m, density, thickness, g=9.82):
    energies = []
    for theta in range(0, 360, 5):
        rad = math.radians(theta)
        R = np.array([[math.cos(rad), -math.sin(rad)], [math.sin(rad), math.cos(rad)]])
        pts_rot = (R @ np.array(polygon).T).T.tolist()
        U = potential_energy(pts_rot, units, m, g, density, thickness)
        energies.append((theta, U))
    return min(energies, key=lambda x: x[1])[0]


class BuoyancyApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Buoyancy Simulator")
        self.configure(bg="#2E2E2E")
        self.geometry("520x380")
        self.resizable(False, False)

        default_font = tkfont.Font(family="Nunito", size=10)
        self.option_add("*Font", default_font)

        self.contour = None
        self.distance = tk.DoubleVar(value=10.0)
        self.mass = tk.DoubleVar(value=100.0)
        self.thickness = tk.DoubleVar(value=1.0)
        self.density = tk.DoubleVar(value=1.0)
        self.image_label = tk.StringVar(value="Файл не выбран или фигура не нарисована")

        style = ttk.Style(self)
        style.theme_use('clam')
        style.configure('TLabel', background='#2E2E2E', foreground='#ECECEC', font=('Nunito',11))
        style.configure('TButton', background='#444444', foreground='#ECECEC', padding=8, font=('Nunito',11))
        style.map('TButton', background=[('active','#555555')])
        style.configure('TEntry', fieldbackground='#3C3C3C', foreground='#ECECEC', font=('Nunito',11))

        ttk.Button(self, text="Выбрать изображение", command=self.on_choose).grid(row=0, column=0, pady=10, padx=5)
        ttk.Button(self, text="Нарисовать фигуру", command=self.draw_shape).grid(row=0, column=1, pady=10, padx=5)
        ttk.Label(self, textvariable=self.image_label).grid(row=1, column=0, columnspan=2, pady=6)
        self._entry_row(2, "Макс. размер (см)", self.distance)
        self._entry_row(3, "Масса (г)", self.mass)
        self._entry_row(4, "Толщина (см)", self.thickness)
        self._entry_row(5, "Плотность (г/см³)", self.density)
        ttk.Button(self, text="Показать равновесие", command=self.show_equilibrium).grid(row=6, column=0, pady=12)
        ttk.Button(self, text="Запустить анимацию", command=self.run_animation).grid(row=6, column=1, pady=12)

    def _entry_row(self, r, text, var):
        ttk.Label(self, text=text).grid(row=r, column=0, sticky="W", padx=(10,5), pady=4)
        ttk.Entry(self, textvariable=var, width=20).grid(row=r, column=1, sticky="E", pady=4)

    def on_choose(self):
        path = filedialog.askopenfilename(title="Выберите изображение", filetypes=(("PNG files","*.png"),("JPEG files","*.jpg"),("All files","*.*")))
        if path:
            self.image_label.set(path.split('/')[-1])
            img = cv2.imread(path, cv2.IMREAD_GRAYSCALE)
            _, bin_img = cv2.threshold(img,127,255,cv2.THRESH_BINARY_INV)
            contours,_ = cv2.findContours(bin_img,cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)
            if contours:
                cnt = contours[0].reshape(-1,2)
                h=img.shape[0]
                self.contour=[(x,h-y) for x,y in cnt]
            else:
                messagebox.showerror("Ошибка","Контур не найден")

    def draw_shape(self):
        win=tk.Toplevel(self)
        win.title("Нарисуйте фигуру")
        canvas=tk.Canvas(win,width=400,height=400,bg='white')
        canvas.pack()
        points=[]
        def click(e):
            x,y=e.x,e.y
            points.append((x,400-y))
            if len(points)>1:
                x0,y0=points[-2]
                canvas.create_line(x0,400-y0,x,y,fill='black',width=2)
        def finish():
            if len(points)<3:
                messagebox.showerror("Ошибка","Нужно минимум 3 точки")
                return
            self.contour=points.copy()
            self.image_label.set("Нарисованная фигура")
            win.destroy()
        canvas.bind('<Button-1>',click)
        ttk.Button(win,text="Готово",command=finish).pack(pady=5)

    def show_equilibrium(self):
        if not self.contour:
            messagebox.showwarning("Внимание","Сначала выберите или нарисуйте фигуру")
            return
        units=find_units(self.contour,self.distance.get())
        area_physical = calculate_area(self.contour) / (units**2)
        S_phys = self.mass.get() / (self.density.get() * self.thickness.get())
        if area_physical <= S_phys:
            messagebox.showinfo("Результат", "Ваша фигурка утонула :(")
            return
        theta=find_equilibrium_angle(self.contour,units,self.mass.get(),self.density.get(),self.thickness.get())
        rad=math.radians(theta)
        R=np.array([[math.cos(rad),-math.sin(rad)],[math.sin(rad),math.cos(rad)]])
        ctr=(R@np.array(self.contour).T).T.tolist()
        h=find_water_level(ctr,S_phys*units**2)/units
        sub=submerged_polygon(ctr,h*units)
        Gx,Gy=calculate_centroid(ctr);
        Bx,By=calculate_centroid(sub)

        win=tk.Toplevel(self)
        win.title(f"Устойчивое равновесие: {theta}°")
        fig,ax=plt.subplots(facecolor='#1E1E1E')
        plt.style.use('dark_background')
        ax.set_facecolor('#1E1E1E')
        poly=Polygon(ctr,closed=True,edgecolor='#00DDFF',fill=False)
        subp=Polygon(sub,closed=True,edgecolor='#00DDFF',facecolor='#003344',alpha=0.5)
        ax.add_patch(poly);ax.add_patch(subp)
        ax.axhline(y=h*units,color='#00DDFF',linestyle='--')
        ax.plot(Gx,Gy,'wo');ax.text(Gx+units*0.02,Gy,'G',color='white')
        ax.plot(Bx,By,'ro');ax.text(Bx+units*0.02,By,'B',color='red')
        ax.axis('equal');ax.axis('off')
        canvas=FigureCanvasTkAgg(fig,master=win);canvas.get_tk_widget().pack(fill=tk.BOTH,expand=True);canvas.draw()

    def run_animation(self):
        pass

if __name__=='__main__':
    app=BuoyancyApp()
    app.mainloop()